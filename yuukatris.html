<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="cyan">
    <title>Hayase Yuuka Website</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="extra.css">
    <link rel="stylesheet" href="chat.css">
    <link rel="icon" href="IMG_6281.ico" type="image/x-icon">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <link rel="manifest" href="manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Hayase Yuuka">
    <link rel="apple-touch-startup-image" href="IMG_6281.ico">

        <!-- Open Graph tags --> 
        <meta property="og:title" content="Hayase Yuuka Website" />
        <meta property="og:description" content="Hayase Yuuka from Blue Archive is my favorite!" />
        <meta property="og:image" content="https://raw.githubusercontent.com/PaulTheBest1000/paulthebest1000-hayase-yuuka-website/refs/heads/master/Screenshot-004.png" />
        <meta property="og:url" content="https://paulthebest1000.github.io/fun-blue-archive-hayase-yuuka-website/" />
        <meta property="og:type" content="website" />
        <meta property="og:site_name" content="Hayase Yuuka Website" />
    
        <!-- Twitter Card tags -->
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="Hayase Yuuka Website" />
        <meta name="twitter:description" content="Hayase Yuuka from Blue Archive is my favorite!" />
        <meta property="twitter:image" content="https://raw.githubusercontent.com/PaulTheBest1000/paulthebest1000-hayase-yuuka-website/refs/heads/master/Screenshot-004.png" />
        <meta name="twitter:url" content="https://paulthebest1000.github.io/fun-blue-archive-hayase-yuuka-website/" />  

        <!-- Optional: SEO keywords -->
        <meta name="keywords" content="Yuuka, Hayase Yuuka">

        <link rel="manifest" href="manifest.json">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <meta name="apple-mobile-web-app-title" content="Hayase Yuuka">
        <link rel="apple-touch-startup-image" href="IMG_6281.ico">
</head>
<body>
<header>
    <!-- Hamburger button for mobile -->
    <button class="menu-toggle" aria-label="Toggle menu">&#9776;</button>

    <nav>
        <ul class="menu" id="nav-menu">
            <li><a href="index.html"><i class="fa-solid fa-home" style="color: blueviolet;"></i> Home</a></li>

            <li class="menu-item">
                <a href="#"><i class="fa fa-desktop" style="color: blueviolet;"></i> Hayase Yuuka Media</a>
                <ul class="dropdown">
                    <li><a href="hayase-yuuka-photos.html"><i class="fa-solid fa-image" style="color: blueviolet;"></i> All Hayase Yuuka Photos</a></li>
                    <li><a href="hayase-yuuka-videos.html"><i class="fa-solid fa-video" style="color: blueviolet;"></i> All Hayase Yuuka Videos</a></li>
                </ul>
            </li>
            
            <li class="menu-item">
                <a href="#"><i class="fa-solid fa-gamepad" style="color: blueviolet;"></i> Hayase Yuuka Games</a>
                <ul class="dropdown">
                    <li><a href="yuuka-math.html"><i class="fa-solid fa-dice" style="color: blueviolet;"></i> Play Yuuka's Math Game</a></li>
                    <li><a href="whack-a-yuuka-weasel.html"><i class="fa-solid fa-gamepad" style="color: blueviolet;"></i> Play Whack-A-Yuuka Game</a></li>
                    <li><a href="yuukatris.html"><i class="fa-solid fa-cubes" style="color: blueviolet;"></i>  Play Yuuka's Tetris Game</a></li>
                    <li><a href="game-results.html"><i class="fa-solid fa-trophy" style="color: blueviolet;"></i> Hayase Yuuka Game Results</a></li>
                </ul>
            </li>

            <li><a href="discord.html"><i class="fa-brands fa-discord" style="color: #7289da;"></i> Discord</a></li>
        </ul>
    </nav>
</header>

    <div id="time">Loading time...</div>
    <div id="calendar">Loading calendar...</div>

    <button id="chat-toggle-btn">üí¨ Chat</button>

    <div id="chat-container">
      <div id="chat-header">üí¨ Chat</div>
    
      <!-- Chat display area -->
      <div id="chat-box">
        <div id="chat-history"></div>
        <div id="missed-counter"></div>
      </div>
    
      <!-- Chat input area -->
      <div id="chat-input-area">
        <input type="text" id="chat-input" placeholder="Type a message..." />
        <button id="send-btn">Send</button>
        <button id="emoji-btn">üòä</button> <!-- button to toggle emoji menu -->
      </div>
    
      <!-- Emoji menu -->
      <div id="emoji-menu" class="emoji-menu">
        <!-- Category tabs -->
        <div id="emoji-categories" class="emoji-categories">
          <button data-category="smileys">üòÑ</button>
          <button data-category="gestures">üôå</button>
          <button data-category="hearts">‚ù§Ô∏è</button>
          <button data-category="animals">üê∂</button>
          <button data-category="food">üçï</button>
          <button data-category="symbols">üî•</button>
        </div>
        <!-- Emoji list container -->
        <div id="emoji-list" class="emoji-list"></div>
      </div>
    
      <div id="typing-indicator" style="font-style: italic; color: #888;"></div>
    
      <!-- Username change -->
      <div id="username-change-area">
        <input type="text" id="change-username-input" placeholder="New username" />
        <button id="change-username-btn">Change Username</button>
      </div>
    
      <!-- Safe ping toggle -->
      <button id="toggle-safe-btn">Safe Pings ON</button>
    </div>

   <div id="online-users-container">
    <div id="online-users-header">üü¢ Online Users</div>
     <ul id="online-users"></ul>
  </div>

  <h1>üß© Yuukatris</h1>
  <input type="text" id="username-input" placeholder="Enter your name">
  <canvas id="game" width="300" height="600"></canvas>
  <p style="color: #6a5acd; font: bold;">Arrow keys/WASD to move ‚Ä¢ Mouse scroll/Q and E to rotate ‚Ä¢ Space to Play/Pause</p>

  <div id="hud">
    <div>Score: <span id="score">0</span></div>
    <div><span id="username-display"></span></div>
    <div>Lines: <span id="lines">0</span></div>
  </div>

  <div id="mobile-controls">
    <button alt="Rotate Counter-Clockwise" id="rotateCCW">‚ü≤</button>
    <button alt="Hard Drop" id="hardDrop">‚á©</button>
    <button alt="Rotate Clockwise" id="rotateCW">‚ü≥</button>
    <button alt="Move Left" id="left">‚óÄ</button>
    <button alt="Start and Pause" id="startPause">‚èØ</button>
    <button alt="Move Right" id="right">‚ñ∂</button>
    <button alt="Soft Drop" id="softDrop">‚ñº</button>
  </div>

  <button id="toggleBtn">üü¢ Start Yuuka Bumper</button>
  <audio id="ricochet" src="whizzby-41134.mp3"></audio>

<script>
async function loadGalleryImages(fromExternal = true) {
  try {
    let imgs;

    if (fromExternal) {
      // fetch from another HTML file
      const response = await fetch("hayase-yuuka-photos.html");
      const text = await response.text();
      const temp = document.createElement("div");
      temp.innerHTML = text;
      imgs = temp.querySelectorAll(".media-item img");
    } else {
      // use images already on this page
      imgs = document.querySelectorAll(".media-item img");
    }

    // build array of safe images only
    return Array.from(imgs)
      .filter(img => img.dataset.safe !== "false") // skip unsafe
      .map(img => img.getAttribute("data-src") || img.getAttribute("src"));

  } catch (e) {
    console.error("Failed to load gallery images", e);
    return [];
  }
}

const colors = ['#ff0000','#00ff00','#0000ff','#ffff00','#ff00ff','#00ffff'];
const numYuukas = 4;

let yuukas = [];
let bumperActive = false;
let animationId = null;
let imageSwitchInterval = null;
let headerHeight = document.querySelector('header')?.offsetHeight || 0;

// --- Helpers ---
function isColliding(a,b){
  return !(
    a.x + a.element.offsetWidth < b.x ||
    a.x > b.x + b.element.offsetWidth ||
    a.y + a.element.offsetHeight < b.y ||
    a.y > b.y + b.element.offsetHeight
  );
}

function flashBorder(u){
  const color = colors[Math.floor(Math.random()*colors.length)];
  u.element.style.border = `3px solid ${color}`;
  setTimeout(()=>u.element.style.border='none',150);
}

function switchImage(u){
  u.element.src = yuukaImages[Math.floor(Math.random()*yuukaImages.length)];
}

function playBounceSound(){ 
  const sound = document.getElementById('ricochet');
  if (!sound) return;
  sound.currentTime = 0; sound.play();
}

// --- Spawn Yuuka Away From Others ---
function spawnYuuka() {
  const img = document.createElement('img');
  img.src = yuukaImages[Math.floor(Math.random() * yuukaImages.length)];
  img.classList.add('yuuka');
  document.body.appendChild(img);

  const width = img.offsetWidth || 120;
  const height = img.offsetHeight || 120;

  let x, y;
  let maxAttempts = 100, attempt = 0;
  do {
    x = Math.random() * (window.innerWidth - width);
    y = headerHeight + Math.random() * (window.innerHeight - height - headerHeight);
    attempt++;
  } while (yuukas.some(u => isColliding({ x, y, element: img }, u)) && attempt < maxAttempts);

  const dx = (Math.random() * 3 + 2) * (Math.random() < 0.5 ? 1 : -1);
  const dy = (Math.random() * 3 + 2) * (Math.random() < 0.5 ? 1 : -1);

  // ‚ú® CLICK TO GLOW ‚ú®
  img.addEventListener('click', () => {
    const color = colors[Math.floor(Math.random() * colors.length)];
    const duration = (Math.random() * 4 + 1) * 1000; // 1‚Äì5s glow

    // Apply glowing border and shadow
    img.style.boxShadow = `0 0 25px 5px ${color}`;
    img.style.border = `3px solid ${color}`;

    // Stop glowing after duration
    setTimeout(() => {
      img.style.boxShadow = 'none';
      img.style.border = 'none';
    }, duration);
  });

  return { element: img, x, y, dx, dy, width, height };
}

// --- Animate ---
function animate() {
  yuukas.forEach((u, i) => {
    u.x += u.dx;
    u.y += u.dy;

    const w = u.element.offsetWidth || u.width;
    const h = u.element.offsetHeight || u.height;

    const maxX = window.innerWidth - w;
    const maxY = window.innerHeight - h;

    // --- Bounce off viewport edges ---
    if (u.x > maxX) {
      u.x = maxX;
      u.dx *= -1;
      flashBorder(u); switchImage(u); playBounceSound();
    }
    if (u.x < 0) {
      u.x = 0;
      u.dx *= -1;
      flashBorder(u); switchImage(u); playBounceSound();
    }
    if (u.y > maxY) {
      u.y = maxY;
      u.dy *= -1;
      flashBorder(u); switchImage(u); playBounceSound();
    }
    if (u.y < headerHeight) {
      u.y = headerHeight;
      u.dy *= -1;
      flashBorder(u); switchImage(u); playBounceSound();
    }

    // --- Collision with other Yuukas ---
    for (let j = i + 1; j < yuukas.length; j++) {
      const v = yuukas[j];
      if (isColliding(u, v)) {
        // Swap directions
        [u.dx, v.dx] = [v.dx, u.dx];
        [u.dy, v.dy] = [v.dy, u.dy];
        flashBorder(u); flashBorder(v);
        switchImage(u); switchImage(v);
        playBounceSound();

        // Calculate overlap
        const overlapX = (u.x + w) - v.x;
        const overlapY = (u.y + h) - v.y;

        // Push apart along strongest overlap axis
        if (Math.abs(overlapX) < Math.abs(overlapY)) {
          if (u.x < v.x) {
            u.x -= overlapX / 2;
            v.x += overlapX / 2;
          } else {
            u.x += overlapX / 2;
            v.x -= overlapX / 2;
          }
        } else {
          if (u.y < v.y) {
            u.y -= overlapY / 2;
            v.y += overlapY / 2;
          } else {
            u.y += overlapY / 2;
            v.y -= overlapY / 2;
          }
        }
      }
    }

    // --- Apply new position ---
    u.element.style.left = u.x + "px";
    u.element.style.top = u.y + "px";
  });

  animationId = requestAnimationFrame(animate);
}

// --- Toggle Bumper ---
const toggleBtn = document.getElementById('toggleBtn');
toggleBtn.addEventListener('click',()=>{
  if(!bumperActive){
    yuukas = [];
    for(let i=0;i<numYuukas;i++) yuukas.push(spawnYuuka());
    bumperActive = true;
    toggleBtn.innerText='üî¥ Stop Yuuka Bumper';
    animate();

    imageSwitchInterval = setInterval(()=>{
      if(bumperActive) yuukas.forEach(u=>{
        if(Math.random()<0.3) switchImage(u);
      });
    },2000);

  } else {
    bumperActive=false;
    cancelAnimationFrame(animationId);
    clearInterval(imageSwitchInterval);
    yuukas.forEach(u=>u.element.remove());
    toggleBtn.innerText='üü¢ Start Yuuka Bumper';
  }
});

// Update header height and resize Yuukas properly
window.addEventListener('resize', () => {
  headerHeight = document.querySelector('header')?.offsetHeight || 0;

  if (bumperActive) {
    yuukas.forEach(u => {
      const w = u.element.offsetWidth;
      const h = u.element.offsetHeight;
      u.x = Math.min(u.x, window.innerWidth - w);
      u.y = Math.max(headerHeight, Math.min(u.y, window.innerHeight - h));
    });
  }
});
</script>

<script>
const Sounds = {
  move: new Audio("click2.ogg"),
  rotate: new Audio("rollover2.ogg"),
  drop: new Audio("drop_001.ogg"),
  line1: new Audio("confirmation_002.ogg"),
  line2: new Audio("confirmation_003.ogg"),
  gameOver: new Audio("error_003.ogg"),
  start: new Audio("open_002.ogg")
};

// üéöÔ∏è Set sane default volumes
Object.assign(Sounds, {
  move: Object.assign(Sounds.move, { volume: 0.25 }),
  rotate: Object.assign(Sounds.rotate, { volume: 0.35 }),
  drop: Object.assign(Sounds.drop, { volume: 0.45 }),
  line: Object.assign(Sounds.line, { volume: 0.6 }),
  gameOver: Object.assign(Sounds.gameOver, { volume: 0.3 }),
  start: Object.assign(Sounds.start, { volume: 0.35 })
});

document.addEventListener("click", unlockAudio, { once: true });
document.addEventListener("keydown", unlockAudio, { once: true });

function unlockAudio() {
  Object.values(Sounds).forEach(s => {
    s.play().then(() => {
      s.pause();
      s.currentTime = 0;
    }).catch(() => {});
  });
}

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const COLS = 10;
const ROWS = 20;
const BLOCK = 30;

let gameRunning = false;
let dropInterval = null;
let fastDropInterval = null;

const board = Array.from({ length: ROWS }, () =>
  Array(COLS).fill(null)
);

// Yuuka images (Option B)
const images = {
  I: new Image(),
  O: new Image(),
  T: new Image(),
  S: new Image(),
  Z: new Image(),
  J: new Image(),
  L: new Image(),
};

images.I.src = "20251111_151954.jpg";
images.O.src = "575989133_760886856982641_8907810304730099885_n.jpg";
images.T.src = "575657884_760537723684221_3441208500950391250_n.jpg";
images.S.src = "illust_125601203_20251127_073221.jpg";
images.Z.src = "20251130_210520.jpg";
images.J.src = "20251118_204537.jpg";
images.L.src = "574835868_760538287017498_1540375751419056094_n.jpg";

const SHAPES = {
  I: [[1,1,1,1]],
  O: [[1,1],[1,1]],
  T: [[0,1,0],[1,1,1]],
  S: [[0,1,1],[1,1,0]],
  Z: [[1,1,0],[0,1,1]],
  J: [[1,0,0],[1,1,1]],
  L: [[0,0,1],[1,1,1]],
};

function randomPiece() {
  const keys = Object.keys(SHAPES);
  const type = keys[Math.floor(Math.random() * keys.length)];
  return { type, shape: SHAPES[type], x: 3, y: 0 };
}

let piece = randomPiece();

function drawBlock(x, y, type) {
  ctx.drawImage(images[type], x * BLOCK, y * BLOCK, BLOCK, BLOCK);
}

function drawGrid() {
  ctx.strokeStyle = 'rgba(200, 200, 200, 0.2)'; // light gray, transparent
  ctx.lineWidth = 1;

  // vertical lines
  for (let x = 0; x <= COLS; x++) {
    ctx.beginPath();
    ctx.moveTo(x * BLOCK, 0);
    ctx.lineTo(x * BLOCK, ROWS * BLOCK);
    ctx.stroke();
  }

  // horizontal lines
  for (let y = 0; y <= ROWS; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * BLOCK);
    ctx.lineTo(COLS * BLOCK, y * BLOCK);
    ctx.stroke();
  }
}

  // üö´ Don't draw falling piece unless game is running
  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // draw grid first
    drawGrid();

  // Draw placed blocks
  board.forEach((row, y) => {
    row.forEach((cell, x) => {
      if (cell) drawBlock(x, y, cell);
    });
  });

  // üö´ Don't draw falling piece unless game is running
  if (!gameRunning) return;

  piece.shape.forEach((row, y) => {
    row.forEach((val, x) => {
      if (val) drawBlock(piece.x + x, piece.y + y, piece.type);
    });
  });
}

function collide(p) {
  return p.shape.some((row, y) =>
    row.some((val, x) => {
      if (!val) return false;
      const nx = p.x + x;
      const ny = p.y + y;
      return nx < 0 || nx >= COLS || ny >= ROWS || board[ny]?.[nx];
    })
  );
}

function merge() {
  piece.shape.forEach((row, y) =>
    row.forEach((val, x) => {
      if (val) board[piece.y + y][piece.x + x] = piece.type;
    })
  );
}

function clearLines() {
  let totalCleared = 0;

  function checkAndClear() {
    let rowsToClear = [];

    // Find all full rows
    for (let y = ROWS - 1; y >= 0; y--) {
      if (board[y].every(cell => cell)) {
        rowsToClear.push(y);
      }
    }

    // No more lines ‚Üí finish
    if (rowsToClear.length === 0) {
      if (totalCleared > 0) {
        linesCleared += totalCleared;

        // üî• Score: 1=100, 2=200, 3=400, 4=800
        const gained = 100 * Math.pow(2, totalCleared - 1);
        score += gained;

        updateHUD();
      }
      return;
    }

    // Count combo clears
    totalCleared += rowsToClear.length;

    // ‚ú® Blink animation
    let blink = 0;
    const blinkInterval = setInterval(() => {
      rowsToClear.forEach(y => {
        for (let x = 0; x < COLS; x++) {
          ctx.fillStyle =
            blink % 2 === 0
              ? "rgba(255,255,255,0.7)"
              : "rgba(0,0,0,0)";
          ctx.fillRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
        }
      });

      blink++;

      if (blink > 3) {
        clearInterval(blinkInterval);

        playLineSound(rowsToClear.length);

        // Remove rows
        rowsToClear.forEach(y => {
          board.splice(y, 1);
          board.unshift(Array(COLS).fill(null));
        });

        drawBoard();

        // üîÅ RECHECK after gravity settles
        setTimeout(checkAndClear, 50);
      }
    }, 100);
  }

  checkAndClear();
}

function rotate(p) {
  const rotated = p.shape[0].map((_, i) =>
    p.shape.map(row => row[i]).reverse()
  );
  const old = p.shape;
  p.shape = rotated;
  if (collide(p)) p.shape = old;
}

function drop() {
  piece.y++;
  
  if (collide(piece)) {
    piece.y--;
    merge();
    clearLines();
    
    // Spawn a new piece
    piece = randomPiece();
    
    // Check if the new piece immediately collides
    if (collide(piece)) {
      gameOver(); // ‚Üê THIS is the Game Over trigger
      return;
    }
  }
  
  drawBoard();
}

// üéÆ Game Control
let wasRunningBeforeHidden = false;
let gamerName = localStorage.getItem("yuukatrisUser") || "";
let score = 0;
let linesCleared = 0;
updateHUD();

const usernameInput = document.getElementById("username-input");

// Pre-fill input if user already registered
if (gamerName) {
  usernameInput.value = gamerName;
  updateHUD();
}

// Register / update username
function registerUser() {
  const value = usernameInput.value.trim();

  if (!value) {
    usernameInput.classList.add("error");
    usernameInput.placeholder = "Name required üëÄ";
    return;
  }

  gamerName = value;
  localStorage.setItem("yuukatrisUser", gamerName);

  usernameInput.classList.remove("error");
  updateHUD();
  startGame(); // üöÄ start only after valid name
}

// Enter key support (nice UX)
usernameInput.addEventListener("keydown", e => {
  if (e.key === "Enter") registerUser();
});

// Force registration before game starts
if (!gamerName) {
  registerUser();
}

function updateHUD() {
  document.getElementById("username-display").textContent = gamerName;
  document.getElementById("score").textContent = score;
  document.getElementById("lines").textContent = linesCleared;
}

function startGame() {
  if (gameRunning) return;

  // üßç Ensure username is registered
  if (!syncUsername()) {
    document.getElementById("username-input").focus();
    return; // no name, no game üò§
  }

  document.getElementById("username-input").disabled = true;

  playSound(Sounds.start);

  // üéÆ Start fresh run
  gameRunning = true;
  updateHUD();
  dropInterval = setInterval(drop, 700);
}

function playSound(sound) {
  if (!sound) return;
  sound.currentTime = 0;
  sound.play().catch(() => {}); // mobile autoplay safety
}

// Utility function to play sound
function playLineSound(linesClearedNow) {
  if (linesClearedNow === 1) {
    Sounds.line1.currentTime = 0;
    Sounds.line1.play();
  } else if (linesClearedNow > 1) {
    Sounds.line2.currentTime = 0;
    Sounds.line2.play();
  }
}

function syncUsername() {
  const input = document.getElementById("username-input");
  const name = input.value.trim();

  if (!name) return false;

  gamerName = name;
  localStorage.setItem("yuukatrisUser", gamerName);
  return true;
}

window.addEventListener("load", () => {
  const saved = localStorage.getItem("yuukatrisUser");
  if (saved) {
    document.getElementById("username-input").value = saved;
    gamerName = saved;
  }
});

function pauseGame() {
  gameRunning = false;
  clearInterval(dropInterval);
  clearInterval(fastDropInterval);
  dropInterval = null;
  fastDropInterval = null;
}

function toggleGame() {
  gameRunning ? pauseGame() : startGame();
}

function gameOver() {
  pauseGame();
  playSound(Sounds.gameOver);
  alert(`üíÄ Game Over! Yuuka has reached the top.

  User: ${gamerName}
  Score: ${score}
  Lines: ${linesCleared}`);

  setTimeout(() => {
    // Clear board
    for (let y = 0; y < ROWS; y++) board[y].fill(null);
    drawBoard();

    // Reset piece so nothing renders early
    piece = randomPiece();

    gameRunning = false;
    fastDropInterval && clearInterval(fastDropInterval);
    fastDropInterval = null;

    drawBoard(); // now shows clean empty grid
  }, 500);
      score = 0;
    linesCleared = 0;
    updateHUD();
  } 1000;


function moveLeft() {
  piece.x--;
  if (collide(piece)) piece.x++;
  else playSound(Sounds.move);
  drawBoard();
}

function moveRight() {
  piece.x++;
  if (collide(piece)) piece.x--;
  else playSound(Sounds.move);
  drawBoard();
}

function hardDrop() {
  while (!collide(piece)) piece.y++;
  piece.y--;
  merge();
  clearLines();
  playSound(Sounds.drop);
  piece = randomPiece();

  if (collide(piece)) {
    gameOver();
    return;
  }
  drawBoard();
}

function startFastDrop(speed = 1) {
  if (fastDropInterval) return;

  fastDropInterval = setInterval(() => {
    piece.y++;
    if (collide(piece)) {
      piece.y--;
      merge();
      clearLines();
      playSound(Sounds.drop);
      piece = randomPiece();

      if (collide(piece)) {
        gameOver();
        return;
      }
    }
    drawBoard();
  }, speed);
}

function stopFastDrop() {
  if (fastDropInterval) {
    clearInterval(fastDropInterval);
    fastDropInterval = null;
  }
}

function rotateCW() {
  rotate(piece);
  playSound(Sounds.rotate);
  drawBoard();
}

function rotateCCW() {
  for (let i = 0; i < 3; i++) rotate(piece);
  playSound(Sounds.rotate);
  drawBoard();
}

document.addEventListener("keydown", e => {
  const blockKeys = [
    "ArrowUp","ArrowDown","ArrowLeft","ArrowRight",
    "KeyW","KeyA","KeyS","KeyD","Space","KeyQ","KeyE"
  ];
  if (blockKeys.includes(e.code)) e.preventDefault();

  // üß† SMART SPACE KEY
    if (e.code === "Space") {
      // If game isn't running yet ‚Üí register username & start
      if (!gameRunning) {
        if (!syncUsername()) {
          document.getElementById("username-input").focus();
          return;
        }
        startGame();
        return;
      }

      // Otherwise ‚Üí pause / resume
      toggleGame();
      return;
    }

  if (!gameRunning) return;

  if (["ArrowLeft","KeyA"].includes(e.code)) moveLeft();
  if (["ArrowRight","KeyD"].includes(e.code)) moveRight();

  // HARD DROP
  if (["ArrowDown","KeyW"].includes(e.code)) {
    hardDrop();
    return;
  }

  // FAST DROP (hold)
  if (["ArrowUp","KeyS"].includes(e.code)) {
    startFastDrop(70); // ‚ö° fast
  }

  // ROTATION
  if (e.code === "KeyE") rotateCW();
  if (e.code === "KeyQ") rotateCCW();
});

document.addEventListener("keyup", e => {
  if (["ArrowUp","KeyS"].includes(e.code)) {
    stopFastDrop();
  }
});

canvas.addEventListener("wheel", e => {
  if (!gameRunning) return;
  e.preventDefault();

  if (e.deltaY > 0) rotateCW();
  else rotateCCW();
}, { passive: false });

document.getElementById("left").onclick = moveLeft;
document.getElementById("right").onclick = moveRight;

document.getElementById("hardDrop").onclick = hardDrop;

document.getElementById("softDrop").ontouchstart =
document.getElementById("softDrop").onmousedown = () => startFastDrop(120);

document.getElementById("softDrop").ontouchend =
document.getElementById("softDrop").onmouseup = stopFastDrop;

document.getElementById("rotateCW").onclick = rotateCW;
document.getElementById("rotateCCW").onclick = rotateCCW;

document.getElementById("startPause").onclick = toggleGame;

// Initial draw
drawBoard();

function saveResultImageToResults(resultImageSrc, gamerName, score) {
  const timestamp = new Date().toLocaleString();
  const result = {
    name: gamerName,
    score: score,
    image: resultImageSrc,
    timestamp: timestamp
  };

  const results = JSON.parse(localStorage.getItem("yuukaResults")) || [];
  results.push(result);
  localStorage.setItem("yuukaResults", JSON.stringify(results));

  // Optional small status update
  const message = document.createElement("div");
  message.textContent = "‚ú® Saving your Yuuka result...";
  message.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #fff;
    background: rgba(0, 0, 0, 0.7);
    padding: 20px;
    text-align: center;
    border-radius: 10px;
    font-size: 18px;
    z-index: 999;
  `;
  document.body.appendChild(message);

  // Redirect to results page after a short delay
  setTimeout(() => {
    window.location.href = "game-results.html";
  }, 10000);
}
</script>

      <script src="script.js"></script>
      <script src="extra.js"></script>

    <!-- Load Socket.IO script -->
    <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
    <script src="chat.js"></script>
</body>
</html>